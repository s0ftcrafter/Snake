<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake</title>
</head>
<style>
    body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background-color: #f0f0f0;
        margin: 0;
        font-family: Arial, Helvetica, sans-serif;
    }

    #gameCanvas {
        border: 2px solid #333333;
        margin: 20px;
        background-color: white;
    }

    #score {
        font-size: 24px;
        margin-bottom: 10;
    }

    #gameOver {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
    }

    #restartButton {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        margin-top: 10px;
    }

    #restartButton:hover {
        background-color: #45a049;
    }
</style>

<body>

    <div id="score">
        Счет: 0
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="gameOver">
        <h2>Игра окончена</h2>
        <p>Ваш счет: <span id="finalScore">0</span></p>
        <button id="restartButton">
            Начать заново
        </button>
    </div>

    <script>
        const GRID_SIZE = 20;
        const CELL_SIZE = 20;


        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreElement = document.getElementById("score");



        canvas.width = GRID_SIZE * CELL_SIZE;
        canvas.height = GRID_SIZE * CELL_SIZE;


        function drawGrid() {
            ctx.strokeStyle = "#dddddd";
            ctx.lineWidth = 0.5;


            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
            }
        }




        const INITIAL_SNAKE_LENGTH = 4;
        const GAME_SPEED = 100;

        let snake = [];
        let direction = "right";
        let nextDirection = "right";
        let gameLoop = null;


        function initSnake() {
            snake = [];


            for (let i = 0; i < INITIAL_SNAKE_LENGTH; i++) {
                snake.push({ x: INITIAL_SNAKE_LENGTH - i - 1, y: 0 });
            }

        }




        function drawSnake() {
            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? "#4caf50" : "#2e7d32";

                ctx.fillRect(
                    segment.x * CELL_SIZE,
                    segment.y * CELL_SIZE,
                    CELL_SIZE - 1,
                    CELL_SIZE - 1
                );
            });
        }



        document.addEventListener("keydown", (event) => {
            switch (event.key) {
                case "ArrowUp":
                    if (direction !== "down") nextDirection = "up";
                    break;
                case "ArrowDown":
                    if (direction !== "up") nextDirection = "down";
                    break;
                case "ArrowLeft":
                    if (direction !== "right") nextDirection = "left";
                    break;
                case "ArrowRight":
                    if (direction !== "left") nextDirection = "right";
                    break;

            }
        });

        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener("touchstart", (event) => {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        });

        canvas.addEventListener("touchmove", (event) => {
            if (!touchStartX || !touchStartY) return;

            const touchEndX = event.touches[0].clientX;
            const touchEndY = event.touches[0].clientY;

            const deltaX = touchEndX - touchEndY;
            const deltaY = touchEndY - touchEndX;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0 && direction !== "left") {
                    nextDirection = "right";
                } else if (deltaX < 0 && direction !== "right") {
                    nextDirection = "left"
                }
            } else {
                if (deltaY > 0 && direction !== "up") {
                    nextDirection = "down";
                } else if (deltaY < 0 && direction !== "down") {
                    nextDirection = "up"
                }
            }

        });




        let food = null;


        function generateFood() {
            do {
                food = {
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE),
                };
            } while (snake.some(segment => segment.x === food.x && segment.y === food.y))
        }




        function drawFood() {
            ctx.fillStyle = "ff4081"


            ctx.beginPath();
            ctx.arc(
                food.x * CELL_SIZE + CELL_SIZE / 2,
                food.y * CELL_SIZE + CELL_SIZE / 2,
                CELL_SIZE / 2 - 1,
                0,
                Math.PI * 2
            );
            ctx.fill()
        }

        let score = 0;

        let isGameOver = false;
        const gameOverElement = document.getElementById("gameOver");
        const finalScoreElement = document.getElementById("finalScore");


        function checkCollision(head) {
            if (
                head.x < 0 ||
                head.x >= GRID_SIZE ||
                head.y < 0 ||
                head.y >= GRID_SIZE
            ) {
                return true;
            }

            return snake.some(
                (segment) => segment.x === head.x && segment.y === head.y
            );
        }


        function gameOver() {
            isGameOver = true;
            finalScoreElement.textContent = score;
            gameOverElement.style.display = "block";
        }

        function update() {
            if (isGameOver) return;

            setTimeout(() => {
                direction = nextDirection;


                const head = { x: snake[0].x, y: snake[0].y };


                switch (direction) {
                    case "up":
                        head.y--;
                        break;
                    case "down":
                        head.y++;
                        break;
                    case "left":
                        head.x--;
                        break;
                    case "right":
                        head.x++;
                        break;
                }

                if (checkCollision(head)) {
                    gameOver();
                    return;
                }

                snake.unshift(head);

                if (head.x === food.x && head.y === food.y) {
                    score += 10;
                    scoreElement.textContent = `Счет: ${score}`
                    generateFood();
                } else {
                    snake.pop();
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();
                drawFood();
                drawSnake();

                gameLoop = requestAnimationFrame(update);
            }, GAME_SPEED)
        }





        function initGame() {
            initSnake();


            direction = "right"
            nextDirection = "right"
            score = 0;
            isGameOver = false;
            scoreElement.textContent = `Счет: ${score}`;
            gameOverElement.style.display = "none";

            generateFood()
            if (gameLoop) cancelAnimationFrame(gameLoop);
            update();
        }

        const restartButton = document.getElementById("restartButton");

        restartButton.addEventListener("click", initGame);
        initGame();

    </script>

</body>

</html>